<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-04-04T15:11:14+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mokbel Karam</title><subtitle>A minimal website for writing and note-taking.</subtitle><author><name>Mokbel Karam</name></author><entry><title type="html">High-order pressure estimates for projection-based Navier-Stokes solvers</title><link href="http://localhost:4000/2022/01/01/High-order-pressure-estimates-for-navier-stokes-solvers.html" rel="alternate" type="text/html" title="High-order pressure estimates for projection-based Navier-Stokes solvers" /><published>2022-01-01T00:00:00+00:00</published><updated>2022-01-01T00:00:00+00:00</updated><id>http://localhost:4000/2022/01/01/High-order-pressure-estimates-for-navier-stokes-solvers</id><content type="html" xml:base="http://localhost:4000/2022/01/01/High-order-pressure-estimates-for-navier-stokes-solvers.html">&lt;p&gt;Explaining how to construct high-order instantaneous pressures for Navier-Stokes solvers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We derive high-order estimates of the instantaneous pressure for projection-type solvers of the incompressible Navier-Stokes equations. Projection methods play a central role in incompressible and low-Mach fluid flow simulations. However, these methods are known to produce a first-order instantaneous pressure at the end of a timestep, even when used with high-order integrators such as Runge-Kutta or Adams-Bashforth methods. In many instances, a high-order pressure is needed when the application demands it, such as turbulent aerodynamic flows, fluid-structure interaction, membrane filtration, and pressure-dependent boundary conditions. The common strategy to circumvent this limitation is to perform a so-called “post-processing” projection which results in an instantaneous pressure of the same order as the time integrator. However, this additional projection adds more cost to a simulation, especially in the context of high-performance computing. For example, in a third-order Runge-Kutta integration, requiring a post-processing projection increases the computational cost by 33%. Therefore, it is desirable to find high-order consistent estimates for the instantaneous pressure without the need for a post-processing projection. In this paper, we introduce a novel approximation to compute high-order estimates for the instantaneous pressure for arbitrary high-order time integrators, without the need for a post-processing projection. Our proposed approximations are independent of the time integration methodology or boundary conditions. We validate our results using various implicit and explicit integrators on different benchmark problems with periodic and time-dependent boundary conditions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Main article in Journal of Computational Physics: &lt;a href=&quot;https://doi.org/10.1016/j.jcp.2021.110925&quot;&gt;https://doi.org/10.1016/j.jcp.2021.110925&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cite as: &lt;em&gt;Karam, M., &amp;amp; Saad, T. (2021). High-order pressure estimates for projection-based Navier-Stokes solvers. Journal of Computational Physics, 110925.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;explainer-video-by-prof-tony-saad&quot;&gt;Explainer Video By Prof. Tony Saad&lt;/h3&gt;
&lt;hr /&gt;
&lt;iframe width=&quot;700&quot; height=&quot;450&quot; src=&quot;https://www.youtube.com/embed/c54oATeNkdo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;summary-slides&quot;&gt;Summary Slides&lt;/h3&gt;
&lt;hr /&gt;
&lt;iframe src=&quot;https://docs.google.com/presentation/d/e/2PACX-1vSZraf11xWCun4DKR7qzeRahnBpTsP-w7d1HxCel2BK8M_3UN_kb2h_8YSxq8ROLhA9WX3PMh97efQw/embed?start=false&amp;amp;loop=false&amp;amp;delayms=5000&quot; frameborder=&quot;0&quot; width=&quot;700&quot; height=&quot;450&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</content><author><name>Mokbel Karam</name></author><category term="Navier-Stokes" /><category term="Projection-Based Solvers" /><category term="High-order" /><summary type="html">Explaining how to construct high-order instantaneous pressures for Navier-Stokes solvers.</summary></entry><entry><title type="html">BuckinghamPy, A Python software for dimensional analysis</title><link href="http://localhost:4000/misc/2021/12/15/buckinghampy.html" rel="alternate" type="text/html" title="BuckinghamPy, A Python software for dimensional analysis" /><published>2021-12-15T00:00:00+00:00</published><updated>2021-12-15T00:00:00+00:00</updated><id>http://localhost:4000/misc/2021/12/15/buckinghampy</id><content type="html" xml:base="http://localhost:4000/misc/2021/12/15/buckinghampy.html">&lt;p&gt;Python code that implements the Buckingham-Pi theorem and return all sets of dimensionless groups.&lt;/p&gt;

&lt;p&gt;Check the &lt;a href=&quot;https://saadgroup.a2hosted.com/bham&quot;&gt;WebApp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mybinder.org/v2/gh/saadgroup/BuckinghamPy/master?filepath=buckinghampy-gui.ipynb&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge_logo.svg&quot; alt=&quot;Binder&quot; /&gt;&lt;/a&gt; (GUI App)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mybinder.org/v2/gh/saadgroup/BuckinghamPy/master?filepath=examples.ipynb&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge_logo.svg&quot; alt=&quot;Binder&quot; /&gt;&lt;/a&gt; (Script)&lt;/p&gt;

&lt;p&gt;The methodology is discussed in the original artictle: &lt;a href=&quot;https://doi.org/10.1016/j.softx.2021.100851&quot;&gt;https://doi.org/10.1016/j.softx.2021.100851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github repo: &lt;a href=&quot;https://github.com/saadgroup/BuckinghamPy&quot;&gt;https://github.com/saadgroup/BuckinghamPy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cite as: Karam, M., &amp;amp; Saad, T. (2021). BuckinghamPy: A Python software for dimensional analysis. SoftwareX, 16, 100851.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Clone the package from the github repository into the current directory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-buildoutcfg&quot;&gt;git clone https://github.com/saadgroup/BuckinghamPy.git . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pip&lt;/code&gt; tool to install the package in the active python evironment&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-buildoutcfg&quot;&gt;pip install .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;Consider a fluid with density R and viscosity V, pumped in a centrifugal pump with power input P, a volume flow rate Q, an impeller diameter E, and a rotational rate G.&lt;/p&gt;

&lt;p&gt;The homogeneous function that relates all these variables is: f(R, V, P, Q, E, G) = 0&lt;/p&gt;

&lt;p&gt;Using the fundamental units (M, L, T), find all the sets of dimensionless terms with the power input P being part of only one dimensionless term per set.&lt;/p&gt;

&lt;p&gt;Using BuckinghamPy, we execute the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-buildoutcfg&quot;&gt;from buckinghampy import BuckinghamPi

Example = BuckinghamPi()
Example.add_variable(name='R', dimensions='M/L^(3)')
Example.add_variable(name='P', dimensions='M*L^(2)/(T^3)', non_repeating=True)
Example.add_variable(name='V', dimensions='M/(T*L)')
Example.add_variable(name='Q', dimensions='L^(3)/T')
Example.add_variable(name='E', dimensions='L')
Example.add_variable(name='G', dimensions='1/T')

Example.generate_pi_terms()

Example.print_all()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/software/readme_result.png&quot; alt=&quot;Latex Rendered Results&quot; /&gt;&lt;/p&gt;

&lt;p&gt;or you can import the graphic user interface only in a Jupyter cell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-buildoutcfg&quot;&gt;from buckinghampy import BuckinghamPiGui

GUI=BuckinghamPiGui()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;see-also&quot;&gt;See Also&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;documentation&quot;&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/saadgroup/BuckinghamPy/blob/master/doc/buckinghampi.m.html&quot;&gt;Documentation&lt;/a&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mokbel Karam</name></author><category term="misc" /><category term="dimensional analysis" /><category term="Buckingham Pi" /><category term="similarity" /><summary type="html">Python code that implements the Buckingham-Pi theorem and return all sets of dimensionless groups.</summary></entry><entry><title type="html">Mitigation Strategies for Airborne Disease Transmission in Orchestras Using Computational Fluid Dynamics (Covid-19)</title><link href="http://localhost:4000/misc/2021/07/11/covid-19.html" rel="alternate" type="text/html" title="Mitigation Strategies for Airborne Disease Transmission in Orchestras Using Computational Fluid Dynamics (Covid-19)" /><published>2021-07-11T00:00:00+00:00</published><updated>2021-07-11T00:00:00+00:00</updated><id>http://localhost:4000/misc/2021/07/11/covid-19</id><content type="html" xml:base="http://localhost:4000/misc/2021/07/11/covid-19.html">&lt;p&gt;How we helped Utah Symphony during the COVID-19 pandemic&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The COVID-19 pandemic forced performing arts groups to cancel shows and entire seasons due to safety concerns for the audience and performers. It is unclear to what extent aerosols generated by wind instruments contribute to exposure because their fate is dependent on the airflow onstage. We use transient, second-order accurate computational fluid dynamics (CFD) simulations and quantitative microbial risk assessment to estimate aerosol concentrations and the associated risk and assess strategies to mitigate exposure in two distinct concert venues. Mitigation strategies involved rearranging musicians and altering the airflow by changing HVAC settings, opening doors, and introducing flow-directing geometries. Our results indicate that the proposed mitigation strategies can reduce aerosol concentrations in the breathing zone by a factor of 100, corresponding to a similar decrease in the probability of infection.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Main Article in Science Advances: &lt;a href=&quot;https://doi.org/10.1126/sciadv.abg4511&quot;&gt;https://doi.org/10.1126/sciadv.abg4511&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The following videos are available on this &lt;a href=&quot;https://www.youtube.com/watch?v=QNAsvuU9HLA&amp;amp;list=PLEaLl6Sf-KIA8zbsHn9jzu0HdrOBNJe2y&quot;&gt;youtube channel&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cite as: &lt;em&gt;Hedworth, H. A., Karam, M., McConnell, J., Sutherland, J. C., &amp;amp; Saad, T. (2021). Mitigation strategies for airborne disease transmission in orchestras using computational fluid dynamics. Science Advances, 7(26), eabg4511.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;baseline-aerosol-concentration-for-abravanel-hall-with-the-original-orchestra-seating-arrangement&quot;&gt;Baseline Aerosol Concentration For Abravanel Hall With The Original Orchestra Seating Arrangement&lt;/h3&gt;
&lt;hr /&gt;

&lt;iframe width=&quot;591&quot; height=&quot;335&quot; src=&quot;https://www.youtube.com/embed/hAiNfGs9ULo?PLEaLl6Sf-KIA8zbsHn9jzu0HdrOBNJe2y&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;aerosol-concentration-for-abravanel-hall-with-the-new-suggested-orchestra-seating-arrangement&quot;&gt;Aerosol Concentration For Abravanel Hall With The New Suggested Orchestra Seating Arrangement&lt;/h3&gt;
&lt;hr /&gt;

&lt;iframe width=&quot;591&quot; height=&quot;335&quot; src=&quot;https://www.youtube.com/embed/89rbN4dJaKs?PLEaLl6Sf-KIA8zbsHn9jzu0HdrOBNJe2y&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;side-by-side-aerosol-concentration-view-the-original-and-the-new-suggested-seating-arrangement&quot;&gt;Side By Side Aerosol Concentration View The Original And The New Suggested Seating Arrangement&lt;/h3&gt;
&lt;hr /&gt;

&lt;iframe width=&quot;591&quot; height=&quot;335&quot; src=&quot;https://www.youtube.com/embed/6b_UuCuJfkU?PLEaLl6Sf-KIA8zbsHn9jzu0HdrOBNJe2y&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name>Mokbel Karam</name></author><category term="misc" /><category term="CFD" /><category term="Covid-19" /><category term="Wasatch" /><summary type="html">How we helped Utah Symphony during the COVID-19 pandemic</summary></entry><entry><title type="html">Low-Cost Runge-Kutta Integrators for Incompressible Flow Simulations</title><link href="http://localhost:4000/2021/06/15/Low-Cost-Runge-Kutta-NSE.html" rel="alternate" type="text/html" title="Low-Cost Runge-Kutta Integrators for Incompressible Flow Simulations" /><published>2021-06-15T00:00:00+00:00</published><updated>2021-06-15T00:00:00+00:00</updated><id>http://localhost:4000/2021/06/15/Low-Cost-Runge-Kutta-NSE</id><content type="html" xml:base="http://localhost:4000/2021/06/15/Low-Cost-Runge-Kutta-NSE.html">&lt;p&gt;Achieving faster incompressible fluid simulations by dropping the pressure projections at the intermediate stages of Runge-Kutta integrators&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We derive a novel class of low-cost explicit Runge-Kutta (RK) methods for the incompressible Navier-Stokes equations using pressure-based methods. Pressure-based methods require the solution of a Poisson equation for the pressure which is subsequently used to enforce mass conservation. In most cases, the Poisson equation is an expensive proposition, especially in the context of high-performance computing, where the cost of data transfers for global linear solvers can reduce scalability. In addition, when coupled with an RK scheme to achieve high accuracy in time, pressure-based methods require a Poisson solve at each intermediate RK stage, rendering pressure-based methods quite costly on large supercomputers. The proposed time integrators eliminate the need for a pressure-Poisson equation at intermediate stages while retaining formal order of accuracy. This is accomplished by deriving rational interpolants of the pressure from previous timesteps while preserving formal order of accuracy. For example, we will show that only one pressure Poisson equation is needed for second, third, and fourth-order Runge-Kutta schemes. We also find that while the proposed schemes impact stability, overall cost savings of up to 40% are still achievable over a wide range of Reynolds numbers. All the proposed integrators result in the same stability regions for cell Reynolds numbers of up to 10 while producing lower stability for larger cell Reynolds numbers.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Main article in Journal of Computational Physics: &lt;a href=&quot;https://doi.org/10.1016/j.jcp.2021.110518&quot;&gt;https://doi.org/10.1016/j.jcp.2021.110518&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cite as: &lt;em&gt;Karam, M., Sutherland, J. C., &amp;amp; Saad, T. (2021). Low-cost Runge-Kutta integrators for incompressible flow simulations. Journal of Computational Physics, 110518.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary-slides&quot;&gt;Summary Slides&lt;/h3&gt;
&lt;hr /&gt;
&lt;iframe src=&quot;https://docs.google.com/presentation/d/e/2PACX-1vSOUD8mv0wq4rnCeo5H8q_rDTLyq0l1lLpo6rbfiPORj8e5Xh8y-w7Tvxh4beHQaEwXMChz4xg08jGo/embed?start=true&amp;amp;loop=true&amp;amp;delayms=5000&quot; frameborder=&quot;0&quot; width=&quot;700&quot; height=&quot;450&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</content><author><name>Mokbel Karam</name></author><category term="Navier-Stokes" /><category term="Projection-Based Solvers" /><category term="Low-Cost" /><summary type="html">Achieving faster incompressible fluid simulations by dropping the pressure projections at the intermediate stages of Runge-Kutta integrators</summary></entry><entry><title type="html">PyModPDE, A python software for modified equation analysis</title><link href="http://localhost:4000/2020/07/11/PyModPDE.html" rel="alternate" type="text/html" title="PyModPDE, A python software for modified equation analysis" /><published>2020-07-11T00:00:00+00:00</published><updated>2020-07-11T00:00:00+00:00</updated><id>http://localhost:4000/2020/07/11/PyModPDE</id><content type="html" xml:base="http://localhost:4000/2020/07/11/PyModPDE.html">&lt;p&gt;Modified equation analysis like a breeze!&lt;/p&gt;

&lt;p&gt;PyModPDE is a Python software for modified equation analysis, it takes a discrete &lt;strong&gt;PDE&lt;/strong&gt; as its input and outputs the modified equation in LaTeX format.&lt;/p&gt;

&lt;p&gt;The methodology is discussed in the original artictle: &lt;a href=&quot;https://doi.org/10.1016/j.softx.2020.100541&quot;&gt;https://doi.org/10.1016/j.softx.2020.100541&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github repo: &lt;a href=&quot;https://github.com/saadgroup/PyModPDE&quot;&gt;https://github.com/saadgroup/PyModPDE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cite as: Mokbel Karam, James C. Sutherland, Tony Saad, PyModPDE: A python software for modified equation analysis, SoftwareX, Volume 12, 2020, 100541, ISSN 2352-7110.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mybinder.org/v2/gh/saadgroup/PyModPDE/master?filepath=examples.ipynb&quot;&gt;&lt;img src=&quot;https://mybinder.org/badge_logo.svg&quot; alt=&quot;Binder&quot; /&gt;&lt;/a&gt;(press launch binder to run the examples.ipynb)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/software/pymodpde.png&quot; alt=&quot;Pymodpde&quot; width=&quot;650&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyModPDE is a Python software that generates the modified equation for a first order time dependent partial differential equation (PDE) of the form
&lt;br /&gt;
&lt;img src=&quot;http://latex.codecogs.com/svg.latex?u_t&amp;space;=&amp;space;\alpha_1&amp;space;u_x&amp;space;&amp;plus;&amp;space;\alpha_2&amp;space;u_xx&amp;space;&amp;plus;&amp;space;\ldots&amp;space;=&amp;space;\sum_1^M&amp;space;\alpha_n&amp;space;\frac{\partial&amp;space;^n&amp;space;u}{\partial&amp;space;x^n}&quot; title=&quot;u_t = \alpha_1 u_x + \alpha_2 u_xx + \ldots = \sum_n=1^M \alpha_n \frac{\partial ^n u}{\partial x^n}&quot; /&gt;
&lt;br /&gt;
Given a certain finite difference scheme for the PDE, 
&lt;br /&gt;
&lt;img src=&quot;http://latex.codecogs.com/svg.latex?\delta_{t}u&amp;plus;\delta_{x}u&amp;space;&amp;plus;&amp;space;&amp;plus;\delta_{xx}u&amp;space;&amp;plus;\ldots&amp;space;=0&quot; title=&quot;\delta_{t}u+\delta_{x}u + +\delta_{xx}u +\ldots =0&quot; /&gt;
&lt;br /&gt;
PyModPDE computes the amplification factor of the finite difference scheme and returns the the modified equation in the form
&lt;br /&gt;
&lt;img src=&quot;http://latex.codecogs.com/svg.latex?u_{t}=a_{1}u_{x}&amp;plus;a_{2}u_{xx}&amp;plus;a_{3}u_{xxx}&amp;plus;\cdots=\sum_1^P&amp;space;a_{n}\frac{\partial^{n}u}{\partial&amp;space;x^{n}}.&quot; title=&quot;u_{t}=a_{1}u_{x}+a_{2}u_{xx}+a_{3}u_{xxx}+\cdots=\sum_n=1^P a_{n}\frac{\partial^{n}u}{\partial x^{n}}.&quot; /&gt;
&lt;br /&gt;
where, in general, there are inifinitely more terms in the modified equation compared to the original PDE (P &amp;gt; M).&lt;/p&gt;

&lt;h1 id=&quot;usage&quot;&gt;Usage&lt;/h1&gt;
&lt;p&gt;To use PyModPDE, one has to instantiate a first order time dependent differential equation object by calling its constructor that has the following signature&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;DifferentialEquation(dependentVarName,independentVarsNames,indices=[i, j, k], timeIndex=n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the user constructs an object of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DifferentialEquation&lt;/code&gt;, the next step is to start constructing the right-hand-side RHS for this equation. Two methods are available to achieve this: the first is to use the member function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expr&lt;/code&gt; which has the following signature&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;expr(order, directionName, time, stencil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second method is to use the dependent variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indices&lt;/code&gt;, and the differential elements of the independent variable defined by the user, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&amp;lt;independentVarsNames&amp;gt;&lt;/code&gt;. The signature of the member function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;dependentVarName&amp;gt;&lt;/code&gt; is as follow&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;&amp;lt;dependentVarName&amp;gt;(time, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time&lt;/code&gt; here is the discrete time at which the expression of the dependent variable is evaluated ex: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+1, n, ...&lt;/code&gt; . &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kwargs&lt;/code&gt;are indicies of the spatial points at which this expression is evaluated, ex: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x=i+1, y=j, ...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After the construction of the rhs expression using one the two previous methods or a combination of both the user can set the rhs for this differential equation by calling the member function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_rhs&lt;/code&gt; that have the following signature&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;set_rhs(expression)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expression&lt;/code&gt; is a symbolic expression of the rhs constructed using the previously described methods.&lt;/p&gt;

&lt;p&gt;Now the member function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate_modified_equation(...)&lt;/code&gt;, can be used to generate the modified equation up to certain number of terms that the user specify, and return the modified equation in latex form. The signature of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate_modified_equation&lt;/code&gt; is as follow&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;generate_modified_equation(nterms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nterms&lt;/code&gt; is a positive integer that indicates the total number of terms in the modified equation.&lt;/p&gt;

&lt;h1 id=&quot;sample-code-snippets&quot;&gt;Sample code snippets&lt;/h1&gt;
&lt;p&gt;Below are some examples of using the PyModPDE software.
Starting with an example of using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expr(...)&lt;/code&gt; with the advection equation in one dimension using Forward Euler for time discretization and UPWIND for spatial discretization&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;from src.pymodpde import DifferentialEquation, i, n 

# defining the advection velocity
a= symbols('a') 

#constructing a time dependent differential equation
DE = DifferentialEquation(dependentVarName='u',independentVarsNames=['x']) 

# method I of constructing the rhs:
advectionTerm1 = DE.expr(order=1,  directionName='x', time=n, stencil=[-1, 0]) 

# setting the rhs of the differential equation
DE.set_rhs(- a * advectionTerm1 )

# displaying the amplification factor
DE.generate_amp_factor()

# computing and displaying the modified equation up to two terms
DE.generate_modified_equation(nterms=2)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, one can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;dependentVarName&amp;gt;(...)&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expr(...)&lt;/code&gt; to construct the discretization of the rhs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;from src.pymodpde import DifferentialEquation, i, n 

# defining the advection velocity
a= symbols('a') 

#constructing a time dependent differential equation
DE = DifferentialEquation(dependentVarName='u',independentVarsNames=['x']) 

# method II of constructing the rhs:
advectionTerm = (DE.u(time=n, x=i) - DE.u(time=n, x=i-1))/DE.dx 

# setting the rhs of the differential equation
DE.set_rhs(- a * advectionTerm )

# displaying the amplification factor
DE.generate_amp_factor()

# computing and displaying the modified equation up to two terms
DE.generate_modified_equation(nterms=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;see-also&quot;&gt;See Also&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;documentation&quot;&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/saadgroup/PyModPDE/blob/master/doc/pymodpde.html&quot;&gt;Documentation&lt;/a&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mokbel Karam</name></author><category term="stabilityanalysis" /><category term="numericalmethods" /><category term="PDE" /><summary type="html">Modified equation analysis like a breeze!</summary></entry></feed>